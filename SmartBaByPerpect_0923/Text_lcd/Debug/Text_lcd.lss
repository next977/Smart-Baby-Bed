
Text_lcd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000003ec  00800100  00000394  00000428  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000394  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000009  008004ec  008004ec  00000814  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000814  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000844  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000058  00000000  00000000  00000884  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000c1b  00000000  00000000  000008dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000911  00000000  00000000  000014f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000040e  00000000  00000000  00001e08  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000e8  00000000  00000000  00002218  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004b3  00000000  00000000  00002300  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000002af  00000000  00000000  000027b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  00002a62  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	6e c0       	rjmp	.+220    	; 0x10e <__vector_12>
  32:	00 00       	nop
  34:	48 c0       	rjmp	.+144    	; 0xc6 <__bad_interrupt>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	43 c0       	rjmp	.+134    	; 0xc8 <__vector_16>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	c0 c0       	rjmp	.+384    	; 0x1fa <__vector_30>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	14 e0       	ldi	r17, 0x04	; 4
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e4 e9       	ldi	r30, 0x94	; 148
  a0:	f3 e0       	ldi	r31, 0x03	; 3
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	ac 3e       	cpi	r26, 0xEC	; 236
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	24 e0       	ldi	r18, 0x04	; 4
  b4:	ac ee       	ldi	r26, 0xEC	; 236
  b6:	b4 e0       	ldi	r27, 0x04	; 4
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a5 3f       	cpi	r26, 0xF5	; 245
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	d8 d0       	rcall	.+432    	; 0x274 <main>
  c4:	65 c1       	rjmp	.+714    	; 0x390 <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <__vector_16>:
								0.01ms 이고, 이것으로 -90도는 0.6ms , 0도 1.5ms , +90도 2.4ms이다.
								(1+4999)ICR값 *2.4ms/20ms=600 (+90도)OCR1값
								0.1ms만큼의 폭을 알기위해서 600/24=25 ,이므로 0.6ms(-90도), 1.5ms(0도), 2.4ms(+90도)
								는 150,375,600이다. 이것들로 인한 공식은
								OCR1A = (600-375)*x/90 +375    =225*x/90 + 375 이다. x에 우리가 원하는 각을 쓰면된다.*/
	OCR3A=pulse;
  c8:	1f 92       	push	r1
  ca:	0f 92       	push	r0
  cc:	0f b6       	in	r0, 0x3f	; 63
  ce:	0f 92       	push	r0
  d0:	11 24       	eor	r1, r1
  d2:	8f 93       	push	r24
  d4:	9f 93       	push	r25
  d6:	f8 94       	cli
  d8:	82 ed       	ldi	r24, 0xD2	; 210
  da:	82 bf       	out	0x32, r24	; 50
  dc:	80 91 ec 04 	lds	r24, 0x04EC	; 0x8004ec <__data_end>
  e0:	8f 5f       	subi	r24, 0xFF	; 255
  e2:	80 93 ec 04 	sts	0x04EC, r24	; 0x8004ec <__data_end>
  e6:	84 36       	cpi	r24, 0x64	; 100
  e8:	51 f4       	brne	.+20     	; 0xfe <__vector_16+0x36>
  ea:	34 9b       	sbis	0x06, 4	; 6
  ec:	fe cf       	rjmp	.-4      	; 0xea <__vector_16+0x22>
  ee:	84 b1       	in	r24, 0x04	; 4
  f0:	95 b1       	in	r25, 0x05	; 5
  f2:	90 93 f1 04 	sts	0x04F1, r25	; 0x8004f1 <result+0x1>
  f6:	80 93 f0 04 	sts	0x04F0, r24	; 0x8004f0 <result>
  fa:	10 92 ec 04 	sts	0x04EC, r1	; 0x8004ec <__data_end>
  fe:	78 94       	sei
 100:	9f 91       	pop	r25
 102:	8f 91       	pop	r24
 104:	0f 90       	pop	r0
 106:	0f be       	out	0x3f, r0	; 63
 108:	0f 90       	pop	r0
 10a:	1f 90       	pop	r1
 10c:	18 95       	reti

0000010e <__vector_12>:
 10e:	1f 92       	push	r1
 110:	0f 92       	push	r0
 112:	0f b6       	in	r0, 0x3f	; 63
 114:	0f 92       	push	r0
 116:	11 24       	eor	r1, r1
 118:	0b b6       	in	r0, 0x3b	; 59
 11a:	0f 92       	push	r0
 11c:	2f 93       	push	r18
 11e:	8f 93       	push	r24
 120:	9f 93       	push	r25
 122:	ef 93       	push	r30
 124:	ff 93       	push	r31
 126:	f8 94       	cli
 128:	e0 91 f2 04 	lds	r30, 0x04F2	; 0x8004f2 <step>
 12c:	f0 e0       	ldi	r31, 0x00	; 0
 12e:	e0 50       	subi	r30, 0x00	; 0
 130:	ff 4f       	sbci	r31, 0xFF	; 255
 132:	80 81       	ld	r24, Z
 134:	8b bb       	out	0x1b, r24	; 27
 136:	e0 91 ed 04 	lds	r30, 0x04ED	; 0x8004ed <sss>
 13a:	f0 91 ee 04 	lds	r31, 0x04EE	; 0x8004ee <sss+0x1>
 13e:	ee 0f       	add	r30, r30
 140:	ff 1f       	adc	r31, r31
 142:	ec 5f       	subi	r30, 0xFC	; 252
 144:	fe 4f       	sbci	r31, 0xFE	; 254
 146:	81 81       	ldd	r24, Z+1	; 0x01
 148:	8b bd       	out	0x2b, r24	; 43
 14a:	e0 91 ed 04 	lds	r30, 0x04ED	; 0x8004ed <sss>
 14e:	f0 91 ee 04 	lds	r31, 0x04EE	; 0x8004ee <sss+0x1>
 152:	ee 0f       	add	r30, r30
 154:	ff 1f       	adc	r31, r31
 156:	ec 5f       	subi	r30, 0xFC	; 252
 158:	fe 4f       	sbci	r31, 0xFE	; 254
 15a:	80 81       	ld	r24, Z
 15c:	8a bd       	out	0x2a, r24	; 42
 15e:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <sss>
 162:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <sss+0x1>
 166:	01 96       	adiw	r24, 0x01	; 1
 168:	90 93 ee 04 	sts	0x04EE, r25	; 0x8004ee <sss+0x1>
 16c:	80 93 ed 04 	sts	0x04ED, r24	; 0x8004ed <sss>
 170:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <sss>
 174:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <sss+0x1>
 178:	8c 32       	cpi	r24, 0x2C	; 44
 17a:	91 40       	sbci	r25, 0x01	; 1
 17c:	31 f4       	brne	.+12     	; 0x18a <__vector_12+0x7c>
 17e:	8b e2       	ldi	r24, 0x2B	; 43
 180:	91 e0       	ldi	r25, 0x01	; 1
 182:	90 93 ee 04 	sts	0x04EE, r25	; 0x8004ee <sss+0x1>
 186:	80 93 ed 04 	sts	0x04ED, r24	; 0x8004ed <sss>
 18a:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <step>
 18e:	8f 5f       	subi	r24, 0xFF	; 255
 190:	80 93 f2 04 	sts	0x04F2, r24	; 0x8004f2 <step>
 194:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <step>
 198:	84 30       	cpi	r24, 0x04	; 4
 19a:	11 f4       	brne	.+4      	; 0x1a0 <__vector_12+0x92>
 19c:	10 92 f2 04 	sts	0x04F2, r1	; 0x8004f2 <step>
 1a0:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <a>
 1a4:	90 91 f4 04 	lds	r25, 0x04F4	; 0x8004f4 <a+0x1>
 1a8:	01 96       	adiw	r24, 0x01	; 1
 1aa:	90 93 f4 04 	sts	0x04F4, r25	; 0x8004f4 <a+0x1>
 1ae:	80 93 f3 04 	sts	0x04F3, r24	; 0x8004f3 <a>
 1b2:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <a>
 1b6:	90 91 f4 04 	lds	r25, 0x04F4	; 0x8004f4 <a+0x1>
 1ba:	88 3e       	cpi	r24, 0xE8	; 232
 1bc:	93 40       	sbci	r25, 0x03	; 3
 1be:	81 f4       	brne	.+32     	; 0x1e0 <__vector_12+0xd2>
 1c0:	87 b7       	in	r24, 0x37	; 55
 1c2:	81 70       	andi	r24, 0x01	; 1
 1c4:	87 bf       	out	0x37, r24	; 55
 1c6:	86 b7       	in	r24, 0x36	; 54
 1c8:	81 70       	andi	r24, 0x01	; 1
 1ca:	86 bf       	out	0x36, r24	; 54
 1cc:	10 92 ee 04 	sts	0x04EE, r1	; 0x8004ee <sss+0x1>
 1d0:	10 92 ed 04 	sts	0x04ED, r1	; 0x8004ed <sss>
 1d4:	10 92 f2 04 	sts	0x04F2, r1	; 0x8004f2 <step>
 1d8:	10 92 f4 04 	sts	0x04F4, r1	; 0x8004f4 <a+0x1>
 1dc:	10 92 f3 04 	sts	0x04F3, r1	; 0x8004f3 <a>
 1e0:	78 94       	sei
 1e2:	ff 91       	pop	r31
 1e4:	ef 91       	pop	r30
 1e6:	9f 91       	pop	r25
 1e8:	8f 91       	pop	r24
 1ea:	2f 91       	pop	r18
 1ec:	0f 90       	pop	r0
 1ee:	0b be       	out	0x3b, r0	; 59
 1f0:	0f 90       	pop	r0
 1f2:	0f be       	out	0x3f, r0	; 63
 1f4:	0f 90       	pop	r0
 1f6:	1f 90       	pop	r1
 1f8:	18 95       	reti

000001fa <__vector_30>:
 1fa:	1f 92       	push	r1
 1fc:	0f 92       	push	r0
 1fe:	0f b6       	in	r0, 0x3f	; 63
 200:	0f 92       	push	r0
 202:	11 24       	eor	r1, r1
 204:	0b b6       	in	r0, 0x3b	; 59
 206:	0f 92       	push	r0
 208:	8f 93       	push	r24
 20a:	ef 93       	push	r30
 20c:	ff 93       	push	r31
 20e:	eb e9       	ldi	r30, 0x9B	; 155
 210:	f0 e0       	ldi	r31, 0x00	; 0
 212:	80 81       	ld	r24, Z
 214:	88 23       	and	r24, r24
 216:	ec f7       	brge	.-6      	; 0x212 <__vector_30+0x18>
 218:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
 21c:	80 93 ef 04 	sts	0x04EF, r24	; 0x8004ef <BUF>
 220:	ff 91       	pop	r31
 222:	ef 91       	pop	r30
 224:	8f 91       	pop	r24
 226:	0f 90       	pop	r0
 228:	0b be       	out	0x3b, r0	; 59
 22a:	0f 90       	pop	r0
 22c:	0f be       	out	0x3f, r0	; 63
 22e:	0f 90       	pop	r0
 230:	1f 90       	pop	r1
 232:	18 95       	reti

00000234 <TIMER_Init>:
void TIMER_Init (void)
{
	// Timer/Count0 사용
	// 타이머를 이용해서 1초를 만들어 주는것이 이프로그램의 목적임!
	// 동작모드와 클럭소스 및 프리스케일러 결정
	TCCR0	=	0x07;  // 0000 0111일때 111은 CSn2, CSn1, CSn0 의 값들이 111로 받아 본책 228페이지의 1024의 분주값.
 234:	87 e0       	ldi	r24, 0x07	; 7
 236:	83 bf       	out	0x33, r24	; 51

	/* 0.01s에 오버플로우 발생, 1/(14745600Hz/1024)ⅹ45 = 0.03s  14745600hz는 cpu의 주파수 인데 이것은 14745600주기이다. 근데 이것의 초를 구하려면 1/14745600이고 
	X144를 해줘야 0.01초 를 만들어 줄 수 있다.*/ 
	// 오버플로우까지 카운트를 144로 설정
	
	TCNT0	=	0xff - 45; /*0xff이면 1111 1111이므로 255까지 카운터를 할 수 있는데, 여기서 256이면 오버풀러 이므로 256을 쓸수가 없어 144를 빼주어 111부터 144개를 카운터 하여
 238:	82 ed       	ldi	r24, 0xD2	; 210
 23a:	82 bf       	out	0x32, r24	; 50
	                          111+144 즉 255를 만들어 주고 다음번 째 카운터에 256을 만들어줘 오버플로우 발생시켜 인터럽트가 걸리게끔 해주기위함임!.*/
	TIMSK |=	1 << TOIE0;	 /* Overflow Interupt Enable  트리거가 완료되어 인터럽트의 요청이 되면 이 값의 (1의 값)을 주어 인터럽트를 허용해주는 레지스터.
 23c:	87 b7       	in	r24, 0x37	; 55
 23e:	81 60       	ori	r24, 0x01	; 1
 240:	87 bf       	out	0x37, r24	; 55
															기본적으로 1<<TOIE0의 연산자를 먼저 수행하고 TIMSK or 1을 수행하므로 TIMSK or 1은 TIMSK도 초기값
															0000 0000 이고 0000 0001이므로 or은 0000 0001로 나타나 진다. 즉 TIMSK는 0000 0001이되며 마지막 0의
															비트값이 1로 작동 된다는 소리이다. (인터럽트의 마스크와 비슷한 맥락)*/
	
	
	TIFR |=	1 << TOV0;	/* set Overflow Interupt Flag  // 이 값의 허용치가 되어 인터럽트가 걸리면 깃발을 들어줘 (1의 값) 인터럽트를 허용해주는 레지스터
 242:	86 b7       	in	r24, 0x36	; 54
 244:	81 60       	ori	r24, 0x01	; 1
 246:	86 bf       	out	0x36, r24	; 54
	                        TIFR도 TOV0이 0비트이기 때문에 TIMSK와 똑같은 역할을 함. 즉 0의 비트가 1로 작동이 된다는 소리 
	                    근데 그러면 구지 TOV0과 연산자를 왜 써주냐면 TIFR의 0의 비트가 무슨 값인지 모르기 때문에 사용자가 책을 펴볼수박에없는데 TOV0와 <<1로 TOV0의
						값을 나타내주어 사용자가 더 편하게 프로그램을 짤 수 있도록 하는 문장. */

	sei();
 248:	78 94       	sei
 24a:	08 95       	ret

0000024c <ADC_Init>:

void ADC_Init()
{
	/*ADMUX = 0x00;           //채널 0사용
	ADCSRA = 0xC2;				  //ADC enable, ADC Start Conversion, 4prescaler 1100 0010*/
	ADMUX	=	0xC1;     	/* ADC1 Channel, ADC멀티플랙서 선택 레지스터 0~4비트까지 mux0~mux4로 즉 1100 0001 0비트의 mux0을 선택
 24c:	81 ec       	ldi	r24, 0xC1	; 193
 24e:	87 b9       	out	0x07, r24	; 7
								7비트, 6비트의 REFS1, REFS0 을 11로 주어 2.56v를 써줌. , 5비트의 ADLAR에 0을 주어 우정렬을 함. */	

	// ADC Module Enable, Free Running Mode, ADC Prescaler : 64
	ADCSRA	=	0xA6;	/* ADC제어/상태 레지스터로 1010 0110 7비트인 ADEN에 1을 주어 ADC를 허용 하고, ADFR에 1을 주어 free running 모드로 
 250:	86 ea       	ldi	r24, 0xA6	; 166
 252:	86 b9       	out	0x06, r24	; 6
							동작, ADPS0~2 까지 총 3비트에 110을 주어 64번으로 분주해 샘플링 .*/
	ADCSRA	|=	0x40;	/* ADC start conversion 0100 0000 or 해서 0100 0000 즉 ADSC비트에 1을 주어서 free running 모드에서 첫 번째 변환을 시작 하기
 254:	36 9a       	sbi	0x06, 6	; 6
 256:	08 95       	ret

00000258 <uart_set>:
							위해 "1"로 설정 , 그다음은 자동으로 변환이 반복됨, free running 모드는 한번 시작하면 자동적으로 adc를 변환*/
}
void uart_set(void) //USART0은 GPS수신용 혹은 블루투스 수신용, USART1은 PC와와의 하이퍼 터미널을 위한것
{
	
	UBRR1H = 0;
 258:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	UBRR1L = 103; //전송속도는 9600bps
 25c:	87 e6       	ldi	r24, 0x67	; 103
 25e:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
	UCSR1A = 0x00;
 262:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
	UCSR1B = 0x98; // receiver와 transmitter 허용
 266:	88 e9       	ldi	r24, 0x98	; 152
 268:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
	UCSR1C = 0x06; // 8bit 단위 송수신
 26c:	86 e0       	ldi	r24, 0x06	; 6
 26e:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
 272:	08 95       	ret

00000274 <main>:
}

int main(void)
{  
	
	TIMER_Init();
 274:	df df       	rcall	.-66     	; 0x234 <TIMER_Init>
	ADC_Init ();		// PORTF = ADC0
 276:	ea df       	rcall	.-44     	; 0x24c <ADC_Init>
	uart_set();
 278:	ef df       	rcall	.-34     	; 0x258 <uart_set>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 27a:	8f e1       	ldi	r24, 0x1F	; 31
 27c:	9e e4       	ldi	r25, 0x4E	; 78
 27e:	01 97       	sbiw	r24, 0x01	; 1
 280:	f1 f7       	brne	.-4      	; 0x27e <main+0xa>
 282:	00 c0       	rjmp	.+0      	; 0x284 <main+0x10>
 284:	00 00       	nop
	_delay_ms(5);
	TCCR3A = 0x82; //FAST PWM mode 14번 설정, top값 ICR1으로 제어가능모드임, OC1A만 1 0을 설정.
 286:	82 e8       	ldi	r24, 0x82	; 130
 288:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
	TCCR3B = 0x1B;	//oc1A 1 0 으로 설정했기 때문에, TCNT값이 top일때 OC1A는 0, OCR1A과 매칭이됬을때 OC1a는 1로 펄스를 설정!
 28c:	8b e1       	ldi	r24, 0x1B	; 27
 28e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
	TCNT3L = 0x00; // low 비트 0으로 초기화
 292:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	TCNT3H = 0x00; // hihg 비트 0으로 초기화
 296:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
	ICR3=4999; //0부터 4999까지 세고 다시 0으로 초기화가 되므로 총 5000개;
 29a:	87 e8       	ldi	r24, 0x87	; 135
 29c:	93 e1       	ldi	r25, 0x13	; 19
 29e:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 2a2:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
	OCR3A=0;	//초기값 0으로 설정.
 2a6:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
 2aa:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	
	
	DDRF = 0x00;             // PORTF.0핀 입력으로 사용
 2ae:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
	SERBO_DDR   = 0x08; //PORTE 3번핀 OC3A핀만 출력으로 사용.
 2b2:	88 e0       	ldi	r24, 0x08	; 8
 2b4:	82 b9       	out	0x02, r24	; 2
	STEP_DDRA		=	0xFF; //스텝모터 출력으로 설정 데이터 값을 받아 동작!	
 2b6:	8f ef       	ldi	r24, 0xFF	; 255
 2b8:	8a bb       	out	0x1a, r24	; 26
	int i = 0;
	//enum Swich;
	sei();	//sei를 꼭 써주어야된다. enaible 인터럽트 (인터럽트 허용하겠다)
 2ba:	78 94       	sei
	while(1)
	{
		if(result>=30)
		{
		
			TCCR1A = 0x54; //ctc모드 설정, ocA 토글으로 설정, 64분주 프리스케일러 설정
 2bc:	b4 e5       	ldi	r27, 0x54	; 84
			TCCR1B = 0x0B;	//ctc모드 설정, ocA 토글으로 설정, 64분주 프리스케일러 설정
 2be:	ab e0       	ldi	r26, 0x0B	; 11
			TCNT1L = 0x00; // low 비트
			TCNT1H = 0x00; // hihg 비트
			OCR1AH=(m_TimeTable[0]>>8);	//처음 OCR1A의 값을 주어서 처음 CTC모드의 매칭값을 주어 OCR1A의 인터럽트를 걸리게끔 초기값을 0번째 초기값을 줌!
 2c0:	7f e7       	ldi	r23, 0x7F	; 127
			OCR1AL=m_TimeTable[0]&0xff;
 2c2:	64 e6       	ldi	r22, 0x64	; 100
			TIMSK  |= 0x10; //카이머 카운터 16비트 1번카운터 허용
			TIFR   |= 0x10; // 타이머카운터 16비트 1번카운터 허용
			sei();
 2c4:	0f 2e       	mov	r0, r31
 2c6:	f5 e0       	ldi	r31, 0x05	; 5
 2c8:	ef 2e       	mov	r14, r31
 2ca:	f0 2d       	mov	r31, r0
 2cc:	d1 2c       	mov	r13, r1
								0.01ms 이고, 이것으로 -90도는 0.6ms , 0도 1.5ms , +90도 2.4ms이다.
								(1+4999)ICR값 *2.4ms/20ms=600 (+90도)OCR1값
								0.1ms만큼의 폭을 알기위해서 600/24=25 ,이므로 0.6ms(-90도), 1.5ms(0도), 2.4ms(+90도)
								는 150,375,600이다. 이것들로 인한 공식은
								OCR1A = (600-375)*x/90 +375    =225*x/90 + 375 이다. x에 우리가 원하는 각을 쓰면된다.*/
	OCR3A=pulse;
 2ce:	e6 e8       	ldi	r30, 0x86	; 134
 2d0:	f0 e0       	ldi	r31, 0x00	; 0
 2d2:	4b ed       	ldi	r20, 0xDB	; 219
 2d4:	51 e0       	ldi	r21, 0x01	; 1
 2d6:	20 e9       	ldi	r18, 0x90	; 144
 2d8:	31 e0       	ldi	r19, 0x01	; 1
			TCNT1H = 0x00; // hihg 비트
			OCR1AH=(m_TimeTable[0]>>8);	//처음 OCR1A의 값을 주어서 처음 CTC모드의 매칭값을 주어 OCR1A의 인터럽트를 걸리게끔 초기값을 0번째 초기값을 줌!
			OCR1AL=m_TimeTable[0]&0xff;
			TIMSK  |= 0x10; //카이머 카운터 16비트 1번카운터 허용
			TIFR   |= 0x10; // 타이머카운터 16비트 1번카운터 허용
			sei();
 2da:	de 2d       	mov	r29, r14
 2dc:	fd 2c       	mov	r15, r13
	sei();	//sei를 꼭 써주어야된다. enaible 인터럽트 (인터럽트 허용하겠다)
	
	
	while(1)
	{
		if(result>=30)
 2de:	80 91 f0 04 	lds	r24, 0x04F0	; 0x8004f0 <result>
 2e2:	90 91 f1 04 	lds	r25, 0x04F1	; 0x8004f1 <result+0x1>
 2e6:	4e 97       	sbiw	r24, 0x1e	; 30
 2e8:	38 f1       	brcs	.+78     	; 0x338 <main+0xc4>
		{
		
			TCCR1A = 0x54; //ctc모드 설정, ocA 토글으로 설정, 64분주 프리스케일러 설정
 2ea:	bf bd       	out	0x2f, r27	; 47
			TCCR1B = 0x0B;	//ctc모드 설정, ocA 토글으로 설정, 64분주 프리스케일러 설정
 2ec:	ae bd       	out	0x2e, r26	; 46
			TCNT1L = 0x00; // low 비트
 2ee:	1c bc       	out	0x2c, r1	; 44
			TCNT1H = 0x00; // hihg 비트
 2f0:	1d bc       	out	0x2d, r1	; 45
			OCR1AH=(m_TimeTable[0]>>8);	//처음 OCR1A의 값을 주어서 처음 CTC모드의 매칭값을 주어 OCR1A의 인터럽트를 걸리게끔 초기값을 0번째 초기값을 줌!
 2f2:	7b bd       	out	0x2b, r23	; 43
			OCR1AL=m_TimeTable[0]&0xff;
 2f4:	6a bd       	out	0x2a, r22	; 42
			TIMSK  |= 0x10; //카이머 카운터 16비트 1번카운터 허용
 2f6:	87 b7       	in	r24, 0x37	; 55
 2f8:	80 61       	ori	r24, 0x10	; 16
 2fa:	87 bf       	out	0x37, r24	; 55
			TIFR   |= 0x10; // 타이머카운터 16비트 1번카운터 허용
 2fc:	86 b7       	in	r24, 0x36	; 54
 2fe:	80 61       	ori	r24, 0x10	; 16
 300:	86 bf       	out	0x36, r24	; 54
			sei();
 302:	78 94       	sei
 304:	8d 2f       	mov	r24, r29
 306:	9f 2d       	mov	r25, r15
								0.01ms 이고, 이것으로 -90도는 0.6ms , 0도 1.5ms , +90도 2.4ms이다.
								(1+4999)ICR값 *2.4ms/20ms=600 (+90도)OCR1값
								0.1ms만큼의 폭을 알기위해서 600/24=25 ,이므로 0.6ms(-90도), 1.5ms(0도), 2.4ms(+90도)
								는 150,375,600이다. 이것들로 인한 공식은
								OCR1A = (600-375)*x/90 +375    =225*x/90 + 375 이다. x에 우리가 원하는 각을 쓰면된다.*/
	OCR3A=pulse;
 308:	51 83       	std	Z+1, r21	; 0x01
 30a:	40 83       	st	Z, r20
 30c:	cf ef       	ldi	r28, 0xFF	; 255
 30e:	03 ed       	ldi	r16, 0xD3	; 211
 310:	10 e3       	ldi	r17, 0x30	; 48
 312:	c1 50       	subi	r28, 0x01	; 1
 314:	00 40       	sbci	r16, 0x00	; 0
 316:	10 40       	sbci	r17, 0x00	; 0
 318:	e1 f7       	brne	.-8      	; 0x312 <main+0x9e>
 31a:	00 c0       	rjmp	.+0      	; 0x31c <main+0xa8>
 31c:	00 00       	nop
 31e:	31 83       	std	Z+1, r19	; 0x01
 320:	20 83       	st	Z, r18
 322:	cf ef       	ldi	r28, 0xFF	; 255
 324:	03 ed       	ldi	r16, 0xD3	; 211
 326:	10 e3       	ldi	r17, 0x30	; 48
 328:	c1 50       	subi	r28, 0x01	; 1
 32a:	00 40       	sbci	r16, 0x00	; 0
 32c:	10 40       	sbci	r17, 0x00	; 0
 32e:	e1 f7       	brne	.-8      	; 0x328 <main+0xb4>
 330:	00 c0       	rjmp	.+0      	; 0x332 <main+0xbe>
 332:	00 00       	nop
 334:	01 97       	sbiw	r24, 0x01	; 1
			OCR1AH=(m_TimeTable[0]>>8);	//처음 OCR1A의 값을 주어서 처음 CTC모드의 매칭값을 주어 OCR1A의 인터럽트를 걸리게끔 초기값을 0번째 초기값을 줌!
			OCR1AL=m_TimeTable[0]&0xff;
			TIMSK  |= 0x10; //카이머 카운터 16비트 1번카운터 허용
			TIFR   |= 0x10; // 타이머카운터 16비트 1번카운터 허용
			sei();
			for(i=0;i<5;i++)
 336:	41 f7       	brne	.-48     	; 0x308 <main+0x94>
				_delay_ms(1000);
				svangle(10);
				_delay_ms(1000);
			}
		}
		switch(BUF)
 338:	80 91 ef 04 	lds	r24, 0x04EF	; 0x8004ef <BUF>
 33c:	81 30       	cpi	r24, 0x01	; 1
 33e:	79 f6       	brne	.-98     	; 0x2de <main+0x6a>
		{
			
			case on:
						TCCR1A = 0x54; //ctc모드 설정, ocA 토글으로 설정, 64분주 프리스케일러 설정
 340:	bf bd       	out	0x2f, r27	; 47
						TCCR1B = 0x0B;	//ctc모드 설정, ocA 토글으로 설정, 64분주 프리스케일러 설정
 342:	ae bd       	out	0x2e, r26	; 46
						TCNT1L = 0x00; // low 비트
 344:	1c bc       	out	0x2c, r1	; 44
						TCNT1H = 0x00; // hihg 비트
 346:	1d bc       	out	0x2d, r1	; 45
						OCR1AH=(m_TimeTable[0]>>8);	//처음 OCR1A의 값을 주어서 처음 CTC모드의 매칭값을 주어 OCR1A의 인터럽트를 걸리게끔 초기값을 0번째 초기값을 줌!
 348:	7b bd       	out	0x2b, r23	; 43
						OCR1AL=m_TimeTable[0]&0xff;
 34a:	6a bd       	out	0x2a, r22	; 42
						TIMSK  |= 0x10; //카이머 카운터 16비트 1번카운터 허용
 34c:	87 b7       	in	r24, 0x37	; 55
 34e:	80 61       	ori	r24, 0x10	; 16
 350:	87 bf       	out	0x37, r24	; 55
						TIFR   |= 0x10; // 타이머카운터 16비트 1번카운터 허용
 352:	86 b7       	in	r24, 0x36	; 54
 354:	80 61       	ori	r24, 0x10	; 16
 356:	86 bf       	out	0x36, r24	; 54
						sei();
 358:	78 94       	sei
 35a:	8e 2d       	mov	r24, r14
 35c:	9d 2d       	mov	r25, r13
								0.01ms 이고, 이것으로 -90도는 0.6ms , 0도 1.5ms , +90도 2.4ms이다.
								(1+4999)ICR값 *2.4ms/20ms=600 (+90도)OCR1값
								0.1ms만큼의 폭을 알기위해서 600/24=25 ,이므로 0.6ms(-90도), 1.5ms(0도), 2.4ms(+90도)
								는 150,375,600이다. 이것들로 인한 공식은
								OCR1A = (600-375)*x/90 +375    =225*x/90 + 375 이다. x에 우리가 원하는 각을 쓰면된다.*/
	OCR3A=pulse;
 35e:	51 83       	std	Z+1, r21	; 0x01
 360:	40 83       	st	Z, r20
 362:	cf ef       	ldi	r28, 0xFF	; 255
 364:	03 ed       	ldi	r16, 0xD3	; 211
 366:	10 e3       	ldi	r17, 0x30	; 48
 368:	c1 50       	subi	r28, 0x01	; 1
 36a:	00 40       	sbci	r16, 0x00	; 0
 36c:	10 40       	sbci	r17, 0x00	; 0
 36e:	e1 f7       	brne	.-8      	; 0x368 <main+0xf4>
 370:	00 c0       	rjmp	.+0      	; 0x372 <main+0xfe>
 372:	00 00       	nop
 374:	31 83       	std	Z+1, r19	; 0x01
 376:	20 83       	st	Z, r18
 378:	cf ef       	ldi	r28, 0xFF	; 255
 37a:	03 ed       	ldi	r16, 0xD3	; 211
 37c:	10 e3       	ldi	r17, 0x30	; 48
 37e:	c1 50       	subi	r28, 0x01	; 1
 380:	00 40       	sbci	r16, 0x00	; 0
 382:	10 40       	sbci	r17, 0x00	; 0
 384:	e1 f7       	brne	.-8      	; 0x37e <main+0x10a>
 386:	00 c0       	rjmp	.+0      	; 0x388 <main+0x114>
 388:	00 00       	nop
 38a:	01 97       	sbiw	r24, 0x01	; 1
						OCR1AH=(m_TimeTable[0]>>8);	//처음 OCR1A의 값을 주어서 처음 CTC모드의 매칭값을 주어 OCR1A의 인터럽트를 걸리게끔 초기값을 0번째 초기값을 줌!
						OCR1AL=m_TimeTable[0]&0xff;
						TIMSK  |= 0x10; //카이머 카운터 16비트 1번카운터 허용
						TIFR   |= 0x10; // 타이머카운터 16비트 1번카운터 허용
						sei();
						for(i=0;i<5;i++)
 38c:	41 f7       	brne	.-48     	; 0x35e <main+0xea>
 38e:	a7 cf       	rjmp	.-178    	; 0x2de <main+0x6a>

00000390 <_exit>:
 390:	f8 94       	cli

00000392 <__stop_program>:
 392:	ff cf       	rjmp	.-2      	; 0x392 <__stop_program>
