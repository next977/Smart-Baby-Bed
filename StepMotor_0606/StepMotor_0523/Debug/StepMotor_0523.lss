
StepMotor_0523.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000003ec  00800100  0000019a  0000022e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000019a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000003  008004ec  008004ec  0000061a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000061a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000064c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000028  00000000  00000000  00000688  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000118  00000000  00000000  000006b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000000b4  00000000  00000000  000007c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000014b  00000000  00000000  0000087c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000058  00000000  00000000  000009c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000180  00000000  00000000  00000a20  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000070  00000000  00000000  00000ba0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  00000c10  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	4b c0       	rjmp	.+150    	; 0xc8 <__vector_12>
  32:	00 00       	nop
  34:	48 c0       	rjmp	.+144    	; 0xc6 <__bad_interrupt>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	14 e0       	ldi	r17, 0x04	; 4
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	ea e9       	ldi	r30, 0x9A	; 154
  a0:	f1 e0       	ldi	r31, 0x01	; 1
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	ac 3e       	cpi	r26, 0xEC	; 236
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	24 e0       	ldi	r18, 0x04	; 4
  b4:	ac ee       	ldi	r26, 0xEC	; 236
  b6:	b4 e0       	ldi	r27, 0x04	; 4
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	af 3e       	cpi	r26, 0xEF	; 239
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	51 d0       	rcall	.+162    	; 0x166 <main>
  c4:	68 c0       	rjmp	.+208    	; 0x196 <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <__vector_12>:
 };
unsigned char mot_tbl[] = {0x0a,0x06,0x05,0x09};// 2상 여자 1.8도 스텝모터 1.8도 스텝모터의 데이터 시트에있는 상에 데이터를 넣어구동하는방법
ISR(TIMER1_COMPA_vect)	/*CTC모드로 설정후 OCR1A에 TCNT1의 값이 매칭이 되었을때 TCNT1은 0으로 초기화되고 COMPA(OCR1A)의 인터럽트 루틴으로 빠진다.
							즉, CTC모드 OCR1A의 인터럽트루틴을 생성해준것이다!
							모터 2개를 동시에 돌리기 위해 4핀 4핀 총 8핀 1포트로 돌리는것!*/
{
  c8:	1f 92       	push	r1
  ca:	0f 92       	push	r0
  cc:	0f b6       	in	r0, 0x3f	; 63
  ce:	0f 92       	push	r0
  d0:	11 24       	eor	r1, r1
  d2:	0b b6       	in	r0, 0x3b	; 59
  d4:	0f 92       	push	r0
  d6:	2f 93       	push	r18
  d8:	8f 93       	push	r24
  da:	9f 93       	push	r25
  dc:	ef 93       	push	r30
  de:	ff 93       	push	r31
	cli();							/* sss++, if문을 돌리고 step ++, if문을 돌리고 난후 OCR1A에 테이블 값을 넣어야 된다
  e0:	f8 94       	cli
									그래야 모터가 터지지도 않고, 인터럽트루틴으로 오면 테이블 sss는 인덱스 1부터 돌아간다!*/
	
	sss++;
  e2:	80 91 ec 04 	lds	r24, 0x04EC	; 0x8004ec <__data_end>
  e6:	90 91 ed 04 	lds	r25, 0x04ED	; 0x8004ed <__data_end+0x1>
  ea:	01 96       	adiw	r24, 0x01	; 1
  ec:	90 93 ed 04 	sts	0x04ED, r25	; 0x8004ed <__data_end+0x1>
  f0:	80 93 ec 04 	sts	0x04EC, r24	; 0x8004ec <__data_end>
	if(sss==500) sss=499;
  f4:	80 91 ec 04 	lds	r24, 0x04EC	; 0x8004ec <__data_end>
  f8:	90 91 ed 04 	lds	r25, 0x04ED	; 0x8004ed <__data_end+0x1>
  fc:	84 3f       	cpi	r24, 0xF4	; 244
  fe:	91 40       	sbci	r25, 0x01	; 1
 100:	31 f4       	brne	.+12     	; 0x10e <__vector_12+0x46>
 102:	83 ef       	ldi	r24, 0xF3	; 243
 104:	91 e0       	ldi	r25, 0x01	; 1
 106:	90 93 ed 04 	sts	0x04ED, r25	; 0x8004ed <__data_end+0x1>
 10a:	80 93 ec 04 	sts	0x04EC, r24	; 0x8004ec <__data_end>
	step ++;
 10e:	80 91 ee 04 	lds	r24, 0x04EE	; 0x8004ee <step>
 112:	8f 5f       	subi	r24, 0xFF	; 255
 114:	80 93 ee 04 	sts	0x04EE, r24	; 0x8004ee <step>
	if(step==4) step=0;
 118:	80 91 ee 04 	lds	r24, 0x04EE	; 0x8004ee <step>
 11c:	84 30       	cpi	r24, 0x04	; 4
 11e:	11 f4       	brne	.+4      	; 0x124 <__vector_12+0x5c>
 120:	10 92 ee 04 	sts	0x04EE, r1	; 0x8004ee <step>
	OCR1AH=(m_TimeTable[sss]>>8); //16비트중 상위 8비트의 값을 주기위해.
 124:	e0 91 ec 04 	lds	r30, 0x04EC	; 0x8004ec <__data_end>
 128:	f0 91 ed 04 	lds	r31, 0x04ED	; 0x8004ed <__data_end+0x1>
 12c:	ee 0f       	add	r30, r30
 12e:	ff 1f       	adc	r31, r31
 130:	ec 5f       	subi	r30, 0xFC	; 252
 132:	fe 4f       	sbci	r31, 0xFE	; 254
 134:	81 81       	ldd	r24, Z+1	; 0x01
 136:	8b bd       	out	0x2b, r24	; 43
	OCR1AL=m_TimeTable[sss]&0xff; //16비트중 하위 8비트의 값을 주기위해.
 138:	e0 91 ec 04 	lds	r30, 0x04EC	; 0x8004ec <__data_end>
 13c:	f0 91 ed 04 	lds	r31, 0x04ED	; 0x8004ed <__data_end+0x1>
 140:	ee 0f       	add	r30, r30
 142:	ff 1f       	adc	r31, r31
 144:	ec 5f       	subi	r30, 0xFC	; 252
 146:	fe 4f       	sbci	r31, 0xFE	; 254
 148:	80 81       	ld	r24, Z
 14a:	8a bd       	out	0x2a, r24	; 42
	sei();
 14c:	78 94       	sei
}
 14e:	ff 91       	pop	r31
 150:	ef 91       	pop	r30
 152:	9f 91       	pop	r25
 154:	8f 91       	pop	r24
 156:	2f 91       	pop	r18
 158:	0f 90       	pop	r0
 15a:	0b be       	out	0x3b, r0	; 59
 15c:	0f 90       	pop	r0
 15e:	0f be       	out	0x3f, r0	; 63
 160:	0f 90       	pop	r0
 162:	1f 90       	pop	r1
 164:	18 95       	reti

00000166 <main>:


void main (void)
{

	TCCR1A = 0x54; //ctc모드 설정, ocA 토글으로 설정, 64분주 프리스케일러 설정 
 166:	84 e5       	ldi	r24, 0x54	; 84
 168:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0x0B;	//ctc모드 설정, ocA 토글으로 설정, 64분주 프리스케일러 설정 
 16a:	8b e0       	ldi	r24, 0x0B	; 11
 16c:	8e bd       	out	0x2e, r24	; 46
	TCNT1L = 0x00; // low 비트
 16e:	1c bc       	out	0x2c, r1	; 44
	TCNT1H = 0x00; // hihg 비트
 170:	1d bc       	out	0x2d, r1	; 45
	TIMSK  = 0x10; //카이머 카운터 16비트 1번카운터 허용
 172:	80 e1       	ldi	r24, 0x10	; 16
 174:	87 bf       	out	0x37, r24	; 55
	TIFR  = 0x10; // 타이머카운터 16비트 1번카운터 허용
 176:	86 bf       	out	0x36, r24	; 54
	OCR1AH=(m_TimeTable[0]>>8);	//처음 OCR1A의 값을 주어서 처음 CTC모드의 매칭값을 주어 OCR1A의 인터럽트를 걸리게끔 초기값을 0번째 초기값을 줌!
 178:	8f e7       	ldi	r24, 0x7F	; 127
 17a:	8b bd       	out	0x2b, r24	; 43
	OCR1AL=m_TimeTable[0]&0xff; 
 17c:	84 e6       	ldi	r24, 0x64	; 100
 17e:	8a bd       	out	0x2a, r24	; 42
	sei();	//sei를 꼭 써주어야된다. enaible 인터럽트 (인터럽트 허용하겠다) 
 180:	78 94       	sei
	
	STEP_DDRA		=	0xFF; //스텝모터 출력으로 설정 데이터 값을 받아 동작!
 182:	8f ef       	ldi	r24, 0xFF	; 255
 184:	8a bb       	out	0x1a, r24	; 26
	while(1)

	{
	
		
		STEP_PORTA			=	mot_tbl[step];	/*0번째 step의 상의 값을 스텝모터에 넣고, 인터럽트에 빠질때마다 다음 스텝의 값을 준다.
 186:	e0 91 ee 04 	lds	r30, 0x04EE	; 0x8004ee <step>
 18a:	f0 e0       	ldi	r31, 0x00	; 0
 18c:	e0 50       	subi	r30, 0x00	; 0
 18e:	ff 4f       	sbci	r31, 0xFF	; 255
 190:	80 81       	ld	r24, Z
 192:	8b bb       	out	0x1b, r24	; 27
										(시간간격이 점점 커지게) 주어야 된다.
										그러기 때문에 CTC모드를 이용하여 CTC모드일때 인터럽트 루틴으로 빠져 main에서 스텝을 주고 난후
										인터럽트에 빠져 다음 시간을 주고(시간을 주기위해 다음 카운터를 준다 (카운터 시간을 주는것) OCR1A의
										값을 주어 다음 인터럽트에 빠지기까지의 시간을 카운터로 주는 방식으로 스텝에 맞춰 시간을 조정할 수 있다!
										그러기떄문에 OCR1A의 값을 스텝모터의 가감속 테이블의 값의 배열로 조작한다.*/
	}
 194:	f8 cf       	rjmp	.-16     	; 0x186 <main+0x20>

00000196 <_exit>:
 196:	f8 94       	cli

00000198 <__stop_program>:
 198:	ff cf       	rjmp	.-2      	; 0x198 <__stop_program>
